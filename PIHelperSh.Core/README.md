## Ядро библиотеки
Содержит в себе некоторый базовый функционал, который активно используется другими библиотеками семейства, а так же может быть использован пользователем.
# Кастомные значения перечислений
Данная функциональность позволяет реализовывать перечисления, значениями которых являются любые объекты языка. Для работы используется анотация **TypeValue<T>**. Пример использования:
``` c#
public enum Test
{   
    [TypeValue<string>("This is string value for 1")]
    [TypeValue<StringSplitOptions>(StringSplitOptions.TrimEntries)]
    value1,

    [TypeValue<string>("This is string value for 1")]
    [TypeValue<Guid>("1a963cd0-3995-44c1-a9d2-64f28f95fec2")]
    value2,

    [TypeValue<TestClass>("{\"count\":12,\"name\":\"test\"}")]
    [TypeValue<string>("This is string value for 1")]
    value3
}
```
Стоит отметить, что значения атрибутов должны быть определены на этапе компиляции, поэтому конструкция new в них невозможна. Из-за этого, предусмотрено 2 механизма:

 - Если существует преобразование из строки, оно применяется (как в случае с GUID)
 - Если такового нет, можно передать в атрибут строку json представляния объекта. Для приведения будет применятся Newtonsoft.json (JsonConvert).
 Для извлечения значения из перечисления используется метод расширения **GetValue<T>()**
``` c#
Test.value1.GetValue<string>();
Test.value2.GetValue<Guid>();
```
При попытке получить из перечисления значение типа, который не был указан, будет возвращено значение по умолчанию (default(T))
Так же имеется возможность обратного преобразования: получить значение перечисления из типа, указанного в анотации. Для этого применяется метод расширения **CreateEnumFromValue<T>**. При этом T - тип перечисления, к которому приводим, а метод применяется к переменной, из которой делаем перечисление:
``` c#
(new Guid("1a963cd0-3995-44c1-a9d2-64f28f95fec2")).CreateEnumFromValue<Test>()
```
Стоит учесть, что сравнение идёт по equals, особенно в случае ссылочных типов.
В случае, если значение не удалось привести будет возвращено значение перечисления по умолчанию (default(T))
## Кастомный компаратор объектов (WIP)
Позволяет выполнять более удобное сравнение объектов, настраиваемое через атрибут **CustomComparation**. Он позволяет определить для каждого поля класса режим сравнения:
 - Default - значение по умолчанию
 - Ignore - игнорируем данное свойство класса при сравнении
 - Comparator - НЕ РАБОТАЕТ В ТЕКУЩЕЙ ВЕРСИИ. Равносилен Default 
 - Equals - сравниваем данное свойство класса по через стандартный equals
Для сравнения объектов появляются 2 метода расширения **Compare(b)** и **Compare<T>(b)**. 

## Тестовое представление объектов
При разработке не редко возникает потребноть в отображении промежуточных значений переменных сложных классов в удобном виде. При этом стандартный метод **toString()** требует перегрузки и часто не подходит для этих целей из коробки. Его требуется перегружать, что, в случае если требуется один раз что-то посмотреть и больше не трогать - чрезмерно затратно. Поэтом, библиотека имеет метод расширения **toText()**. Он позволяет представить объект в виде текста в формате, чем-то схожем с json, но так же, например, с указанием типов. 
Данный инструмент сугубо отладочный и может(в случае циклических зависимостей) работать некорректно. Однако, в случае ситуации, наподобие описанной в начале он может помочь.
## Мелкие улучшения жизни
В данный раздел попали функции, которые используются самой библиотекой и могут частично облегчить рутинные операции.
 1. Метод расширения для string Multiply(int n). Возвращает строку, представляющую собой последовательно повторённую n раз изначальную строку
 2. Метод PowInt(int a, int b). Возвращает значение a в целочисленную степени b. Реализация немного оптимизирована.
 3. Метод расширения string IsNullOrEmpty(). Просто обёртка над string.IsNullOrEmpty(). 

